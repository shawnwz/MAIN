/** * Stub for EPG: CCOM.EPG, a singleton added since v5.0.0 * @ignore */CCOM.EPG = new (function EPG (){	//"use strict";	this._MY_NAME_SPACE = "CCOM.EPG";	this._id = CCOM.stubs.uuid();		this._EVENT_REMOVE_FAVORITE_LIST_OK = "removeFavoriteListOK";	this._EVENT_REMOVE_FAVORITE_LIST_FAILED = "removeFavoriteListFailed";	this._EVENT_SET_FAVORITE_LIST_OK = "setFavoriteListOK";	this._EVENT_SET_FAVORITE_LIST_FAILED = "setFavoriteListFailed";	this._EVENT_ADD_SERVICE_OK = "addServiceOK";	this._EVENT_ADD_SERVICE_FAILED = "addServiceFailed";	this._EVENT_ADD_EVENT_OK = "addEventOK";	this._EVENT_ADD_EVENT_FAILED = "addEventFailed";	this._EVENT_REMOVE_EVENT_OK = "removeEventOK";	this._EVENT_REMOVE_EVENT_FAILED = "removeEventFailed";	this._EVENT_REMOVE_SERVICE_OK = "removeServiceOK";	this._EVENT_REMOVE_SERVICE_FAILED = "removeServiceFailed";	this._EVENT_BEGIN_BATCH_OK = "beginBatchOK";	this._EVENT_BEGIN_BATCH_FAILED = "beginBatchFailed";	this._EVENT_CANCEL_BATCH_OK = "cancelBatchOK";	this._EVENT_CANCEL_BATCH_FAILED = "cancelBatchFailed";	this._EVENT_COMMIT_BATCH_OK = "commitBatchOK";	this._EVENT_COMMIT_BATCH_FAILED = "commitBatchFailed";	this._EVENT_REMOVE_EXPIRED_EVENTS_OK = "removeExpiredEventsOK";	this._EVENT_REMOVE_EXPIRED_EVENTS_FAILED = "removeExpiredEventsFailed";	this._EVENT_TAG_SERVICE_OK = "tagServiceOK";	this._EVENT_TAG_SERVICE_FAILED = "tagServiceFailed";	this._EVENT_UNTAG_EVENT_OK = "untagEventOK";	this._EVENT_UNTAG_EVENT_FAILED = "untagEventFailed";	this._EVENT_UNTAG_SERVICE_OK = "untagServiceOK";	this._EVENT_UNTAG_SERVICE_FAILED = "untagServiceFailed";	this._EVENT_TAG_EVENT_OK = "tagEventOK";	this._EVENT_TAG_EVENT_FAILED = "tagEventFailed";	this._EVENT_GET_SERVICES_RS_BY_COMPONENT_OK = "getServicesRSByComponentOK";	this._EVENT_GET_SERVICES_RS_BY_COMPONENT_FAILED = "getServicesRSByComponentFailed";	this._EVENT_GET_EVENTS_RS_BY_COMPONENT_OK = "getEventsRSByComponentOK";	this._EVENT_GET_EVENTS_RS_BY_COMPONENT_FAILED = "getEventsRSByComponentFailed";	this._EVENT_GET_COMPONENTS_BY_SERVICE_ID_OK = "getComponentsByServiceIdOK";	this._EVENT_GET_COMPONENTS_BY_SERVICE_ID_FAILED = "getComponentsByServiceIdFailed";	this._EVENT_GET_COMPONENTS_BY_EVENT_ID_OK = "getComponentsByEventIdOK";	this._EVENT_GET_COMPONENTS_BY_EVENT_ID_FAILED = "getComponentsByEventIdFailed";	this._supportedEvents = [		this._EVENT_REMOVE_FAVORITE_LIST_OK,		this._EVENT_REMOVE_FAVORITE_LIST_FAILED,		this._EVENT_SET_FAVORITE_LIST_OK,		this._EVENT_SET_FAVORITE_LIST_FAILED,		this._EVENT_ADD_SERVICE_OK,		this._EVENT_ADD_SERVICE_FAILED,		this._EVENT_ADD_EVENT_OK,		this._EVENT_ADD_EVENT_FAILED,		this._EVENT_REMOVE_EVENT_OK,		this._EVENT_REMOVE_EVENT_FAILED,		this._EVENT_REMOVE_SERVICE_OK,		this._EVENT_REMOVE_SERVICE_FAILED,		this._EVENT_BEGIN_BATCH_OK,		this._EVENT_BEGIN_BATCH_FAILED,		this._EVENT_CANCEL_BATCH_OK,		this._EVENT_CANCEL_BATCH_FAILED,		this._EVENT_COMMIT_BATCH_OK,		this._EVENT_COMMIT_BATCH_FAILED,		this._EVENT_REMOVE_EXPIRED_EVENTS_OK,		this._EVENT_REMOVE_EXPIRED_EVENTS_FAILED,		this._EVENT_TAG_SERVICE_OK,		this._EVENT_TAG_SERVICE_FAILED,		this._EVENT_UNTAG_EVENT_OK,		this._EVENT_UNTAG_EVENT_FAILED,		this._EVENT_UNTAG_SERVICE_OK,		this._EVENT_UNTAG_SERVICE_FAILED,		this._EVENT_TAG_EVENT_OK,		this._EVENT_TAG_EVENT_FAILED,		this._EVENT_GET_SERVICES_RS_BY_COMPONENT_OK,		this._EVENT_GET_SERVICES_RS_BY_COMPONENT_FAILED,		this._EVENT_GET_EVENTS_RS_BY_COMPONENT_OK,		this._EVENT_GET_EVENTS_RS_BY_COMPONENT_FAILED,		this._EVENT_GET_COMPONENTS_BY_SERVICE_ID_OK,		this._EVENT_GET_COMPONENTS_BY_SERVICE_ID_FAILED,		this._EVENT_GET_COMPONENTS_BY_EVENT_ID_OK,		this._EVENT_GET_COMPONENTS_BY_EVENT_ID_FAILED	];	this.getServicesRSByQuery = function(fields, criteria, order)	{		var results = [], i, rs, compareChannelKeyAsc = function(a, b)		{			return a.channelKey - b.channelKey;		}, compareChannelKeyDsc = function(a, b)		{			return b.channelKey - a.channelKey;		};		if (CCOM.stubs.stbData.epg.db)		{			var stmt = CCOM.stubs.stbData.epg.db.prepare('SELECT ' + fields + ' FROM Service ' + (criteria ? 'WHERE ' + criteria : '')					+ (order ? ' ORDER BY ' + order : ''));			while (stmt.step())			{				results.push(stmt.getAsObject());			}	    	if(results.length>0 && !results[0].name && !results[0].providerName && !results[0].uriLogo)	    	{                  			        		for(var i=0;i<results.length-1;i++)        		{        			var stmt1 = CCOM.stubs.stbData.epg.db.prepare('SELECT * FROM ServiceText WHERE serviceId_Key = "' + results[i].serviceId + '"');        			if(stmt1.step())		        	{		        		var serviceID = stmt1.getAsObject().serviceId_Key;		        	}        			if(results[i].serviceId == serviceID)        			{        				results[i].name = stmt1.getAsObject().name;						results[i].providerName = stmt1.getAsObject().providerName;						results[i].uriLogo = stmt1.getAsObject().uriLogo;        			}        		}     	        			        }	    }		else		{			if (criteria && criteria !== "")			{				if (criteria.substr(0, 7) === "type in")                {                    var data = criteria.substring(7, criteria.length).trim();                    data = data.substring(1, data.length -1).split(',');                    for(i = 0; i < data.length; i++)                    {                        for (j = 0; j < CCOM.stubs.stbData.epg.serviceData.length; j += 1)                        {                            if (String(CCOM.stubs.stbData.epg.serviceData[j].type) === data[i].trim())                            {                                results.push(CCOM.stubs.stbData.epg.serviceData[j]);                            }                        }                    }                }				else if (criteria.substr(0, 12) === "servicesType")				{					for (i = 0; i < CCOM.stubs.stbData.epg.serviceData.length; i += 1)					{						if (String(CCOM.stubs.stbData.epg.serviceData[i].type) === criteria.substring(13, criteria.length))						{							results.push(CCOM.stubs.stbData.epg.serviceData[i]);						}					}				}				else if (criteria.substr(0, 9) === "serviceId")				{					for (i = 0; i < CCOM.stubs.stbData.epg.serviceData.length; i += 1)					{						if (String(CCOM.stubs.stbData.epg.serviceData[i].serviceId) === criteria.substring(10, criteria.length))						{							results.push(CCOM.stubs.stbData.epg.serviceData[i]);						}					}				}				else				{					this.logInfo("[CCOM.EPG.getServicesRSByQuery] Did not catch it in criteria parsing.");					results = CCOM.stubs.stbData.epg.serviceData;				}			}			else			{				results = CCOM.stubs.stbData.epg.serviceData;			}			if (results.length === 0)			{				this.logInfo("[CCOM.EPG.getServicesRSByQuery] Did not catch it in the condition of RS.length==0.");			}			else if (order === "channelKey asc")			{				results.sort(compareChannelKeyAsc);			}			else if (order === "channelKey dsc")			{				results.sort(compareChannelKeyDsc);			}		}		rs = new CCOM.ResultSet(results);		return rs;	};	this.getEventsRSByQuery = function(fields, criteria, order)	{		var results = [], matchArray = [], matchArray2 = [], rs, i, serviceListArray = [], serviceList, startTime, endTime, j, pattern;		if (CCOM.stubs.stbData && CCOM.stubs.stbData.epg.db)		{			var stmt = CCOM.stubs.stbData.epg.db.prepare('SELECT ' + fields + ' FROM Event ' + (criteria ? 'WHERE ' + criteria : '')					+ (order ? ' ORDER BY ' + order : ''));			while (stmt.step())			{				results.push(stmt.getAsObject());			}		}		else		{			if (criteria && criteria !== "")			{				// serviceId = '352' AND startTime <= 1367045620407 AND endTime > 1367045620407				if (null !== (matchArray = new RegExp(/^serviceId = '(\d+)' AND startTime <= (\d+) AND endTime > (\d+)$/g).exec(criteria)))				{					for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)					{						if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === matchArray[1])						{							results.push(CCOM.stubs.stbData.epg.eventData[i]);						}					}					// eventId = '101'				}				else if (null !== (matchArray = new RegExp(/^eventId = '(\d+)'/g).exec(criteria)))				{					for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)					{						if (String(CCOM.stubs.stbData.epg.eventData[i].eventId) === matchArray[1])						{							results.push(CCOM.stubs.stbData.epg.eventData[i]);						}					}					// criteria: (serviceId='352' OR serviceId='353' OR serviceId='480' OR serviceId='681' OR serviceId='1711' OR serviceId='1712') AND startTime <= '1367056110082' AND endTime >= '1367056110082'"					// fields: "DISTINCT serviceId, title"				}				else if ((null !== (matchArray = new RegExp(/^\(([\w\s=']+)\) AND startTime <= '(\d+)' AND endTime >= '(\d+)'/g)						.exec(criteria)))						||						//duplicated check because gravity was using incorrect data type for the time						(null !== (matchArray = new RegExp(/^\(([\w\s=']+)\) AND startTime <= (\d+) AND endTime >= (\d+)/g).exec(criteria)))						||						// criteria: "serviceId IN ( '352','353','480','681','1711','1712') AND startTime <= '1402576425030' AND endTime >= '1402576425030'"						(null !== (matchArray2 = new RegExp(/^serviceId IN \(([\s\S]*)\) AND startTime <= '(\d+)' AND endTime >= '(\d+)'/g)								.exec(criteria)))						|| (null !== (matchArray2 = new RegExp(/^serviceId IN \(([\s\S]*)\) AND startTime <= (\d+) AND endTime >= (\d+)/g)								.exec(criteria))))				{					if (matchArray)					{						serviceList = matchArray[1];						startTime = matchArray[2];						endTime = matchArray[3];						pattern = /serviceId='(\d+)'/g;					}					else					{						serviceList = matchArray2[1];						startTime = matchArray2[2];						endTime = matchArray2[3];						pattern = /'(\d+)'/g;					}					while ((matchArray = pattern.exec(serviceList)) !== null)					{						serviceListArray.push(matchArray[1]);					}					for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)					{						for (j = 0; j < serviceListArray.length; j++)						{							if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === serviceListArray[j]									&& CCOM.stubs.stbData.epg.eventData[i].startTime <= startTime									&& CCOM.stubs.stbData.epg.eventData[i].endTime >= endTime)							{								results.push(CCOM.stubs.stbData.epg.eventData[i]);							}						}					}					// criteria: "serviceId IN ('352') AND endTime > 1367919907170 AND startTime < 1368458999000"				}				else if (null !== (matchArray = new RegExp(/^serviceId IN \('(\d+)'\) /g).exec(criteria)))				{					for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)					{						if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === matchArray[1])						{							results.push(CCOM.stubs.stbData.epg.eventData[i]);						}					}					// criteria: serviceId = '352' AND ...				}				else if (null !== (matchArray = new RegExp(/^serviceId = '(\d+)' /).exec(criteria)))				{					for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)					{						if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === matchArray[1])						{							results.push(CCOM.stubs.stbData.epg.eventData[i]);						}					}			//@HdK criteria: "startTime <= 1484037583252 and endTime >= 1484037583252 and serviceId like 'NGD_SO'"					// criteria: "startTime <= 1368458999000 and endTime >= 1368458999000 and serviceId like '511'"				}				else if (null !== (matchArray = new RegExp(/^startTime <= (\d+) and endTime >= (\d+) and serviceId like '(\d+)'$/g)						.exec(criteria)))				{					for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)					{						if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === matchArray[3]								&& CCOM.stubs.stbData.epg.eventData[i].startTime <= matchArray[1]								&& CCOM.stubs.stbData.epg.eventData[i].endTime >= matchArray[2])						{							results.push(CCOM.stubs.stbData.epg.eventData[i]);						}					}				}				else				{					this.logInfo("Did not catch it in CCOM.EPG.getEventsRSByQuery, criteria parsing.");				}			}			else			{				results = CCOM.stubs.stbData.epg.eventData;			}			if (results.length === 0)			{				this.logInfo("Did not catch it in CCOM.EPG.getEventsRSByQuery, RS.length==0.");				this.logInfo("criteria: " + criteria);				this.logInfo("fields: " + fields);			}		}		rs = new CCOM.ResultSet(results);		return rs;	};	this.getEventById = function(eventId)	{	//	this.logEntry();		if (CCOM.stubs.stbData.epg.db)		{			var stmt = CCOM.stubs.stbData.epg.db.prepare('SELECT * FROM Event WHERE EventId = "' + eventId + '"');			if (stmt.step())			{				return stmt.getAsObject();			}			return null;		}		else		{			var i;			for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)			{				if (CCOM.stubs.stbData.epg.eventData[i].eventId === eventId)				{					return CCOM.stubs.stbData.epg.eventData[i];				}			}			return null;		}	};	this.getEventCurrent = function(serviceId)	{		var i, curTime = new Date().getTime();		if (CCOM.stubs.stbData.epg.db)		{			var stmt = CCOM.stubs.stbData.epg.db.prepare('SELECT * FROM Event WHERE serviceId = "' + serviceId + '"' + ' and startTime < '					+ curTime + ' and endTime > ' + curTime);    		if(stmt.step())    		{    			return stmt.getAsObject();    		}else{    			var stmt = CCOM.stubs.stbData.epg.db.prepare('SELECT * FROM Event WHERE serviceId = "' + serviceId + '"' +    				' and startTime < "' + curTime+'"');    			if(stmt.step())        		{        			if( !stmt.getAsObject().title){        				var stmt1 = CCOM.stubs.stbData.epg.db.prepare('SELECT * FROM EventText WHERE eventId_Key = "' + stmt.getAsObject().eventId + '"');        				if(stmt1.step())		        		{		        			var eventID = stmt1.getAsObject().eventId_Key;		        			if(stmt.getAsObject().eventId == eventID){		        				var result = stmt.getAsObject();		        				result.title = stmt1.getAsObject().title;		        				result.seriesName = stmt1.getAsObject().seriesName;		        				result.longDesc = stmt1.getAsObject().longDesc;		        				result.shortDesc = stmt1.getAsObject().shortDesc;		        				return result;		        			}		        		}        			}        		}    		}			return null;		}		else		{			for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)			{				if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === String(serviceId)						&& CCOM.stubs.stbData.epg.eventData[i].startTime < curTime && CCOM.stubs.stbData.epg.eventData[i].endTime > curTime)				{					return CCOM.stubs.stbData.epg.eventData[i];				}			}			return null;		}	};	this.getEventNext = function(eventId)	{		if (CCOM.stubs.stbData.epg.db)		{			this.logWarning("This API has not been implemented yet!");			return {				error : {					domain : "com.opentv.CCOM",					name : "Failed",					message : "Not implemented yet"				}			};		}		else		{			var i, event = this.getEventById(eventId);			if (!event)			{				return null;			}			/* Assumes that next event start's time equals the specified event's end time */			for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)			{				if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === String(event.serviceId)						&& CCOM.stubs.stbData.epg.eventData[i].startTime === event.endTime)				{					return CCOM.stubs.stbData.epg.eventData[i];				}			}		}		return null;	};	this.getEventPrevious = function(eventId)	{		if (CCOM.stubs.stbData.epg.db)		{			this.logWarning("This API has not been implemented yet!");			return {				error : {					domain : "com.opentv.CCOM",					name : "Failed",					message : "Not implemented yet"				}			};		}		else		{			var i, event = this.getEventById(eventId);			if (!event)			{				return null;			}			/* Assumes that previous event's end time equals the specified event's start time */			for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)			{				if (String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === String(event.serviceId)						&& CCOM.stubs.stbData.epg.eventData[i].endTime === event.startTime)				{					return CCOM.stubs.stbData.epg.eventData[i];				}			}		}		return null;	};	//Notice:input parameter serviceIds is a array.	this.getEventsByWindow = function(serviceIds, start, end)	{		var i, j, events = [];		if (CCOM.stubs.stbData.epg.db)		{			var stmt = CCOM.stubs.stbData.epg.db.prepare('SELECT * FROM Event WHERE serviceId in ("' + serviceIds.join('","')					+ '") \        				AND startTime < ' + end + ' AND endTime > ' + start);			while (stmt.step())			{				events.push(stmt.getAsObject());			}		}		else		{			for (i = 0; i < serviceIds.length; i++)			{				for (j = 0; j < CCOM.stubs.stbData.epg.eventData.length; j++)				{					if (String(CCOM.stubs.stbData.epg.eventData[j].serviceId) === String(serviceIds[i])							&& CCOM.stubs.stbData.epg.eventData[j].startTime < end && CCOM.stubs.stbData.epg.eventData[j].endTime > start)					{						events.push(CCOM.stubs.stbData.epg.eventData[j]);					}				}			}		}		return events;	};	this.getEventsRSByExtInfo = function(properties, extInfo, criteria, orderBy)	{		var results = [], rs, extInfoKey, extInfoValue, extInfoLanguage, matchArray = [];		if (extInfo.extInfoKey)		{			extInfoKey = extInfo.extInfoKey;		}		if (extInfo.extInfoValue)		{			extInfoValue = extInfo.extInfoValue;		}		if (extInfo.extInfoLanguage)		{			extInfoLanguage = extInfo.extInfoLanguage;		}		if (CCOM.stubs.stbData && CCOM.stubs.stbData.epg.db)		{			var query = 'SELECT ' + properties + ' FROM Event, EventExtInfo where Event.eventId = EventExtInfo.eventId_Key ';			if (extInfoKey)			{				query += 'AND extInfoKey="' + extInfoKey + '" ';			}			if (extInfoValue)			{				query += 'AND extInfoValue LIKE "%' + extInfoKey + '%" ';			}			if (criteria)			{				query += 'AND ' + criteria + ' ';			}			if (orderBy)			{				query += 'ORDER BY ' + orderBy;			}			if (extInfoLanguage && extInfoLanguage != 'all')			{				query += 'AND extInfoLanguage="' + extInfoLanguage + '"';			}			var stmt = CCOM.stubs.stbData.epg.db.prepare(query);			while (stmt.step())			{				results.push(stmt.getAsObject());			}		}		else		{			for (var i = 0; i < CCOM.stubs.stbData.epg.eventExtData.length; i++)			{				if (CCOM.stubs.stbData.epg.eventExtData[i].extInfoLanguage == extInfoLanguage)				{					for (var j = 0; j < CCOM.stubs.stbData.epg.eventExtData[i].extInfo.length; j++)					{						if (CCOM.stubs.stbData.epg.eventExtData[i].extInfo[j].extInfoKey == extInfoKey								&& CCOM.stubs.stbData.epg.eventExtData[i].extInfo[j].extInfoValue.indexOf(extInfoValue) > -1)						{							if (null !== (matchArray = new RegExp(/^eventId = '(\d+)'/g).exec(criteria)))							{								for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)								{									if (String(CCOM.stubs.stbData.epg.eventData[i].eventId) === matchArray[1])									{										CCOM.stubs.stbData.epg.eventData[i].extInfoLanguage = CCOM.stubs.stbData.epg.eventExtData[i].extInfoLanguage;										CCOM.stubs.stbData.epg.eventData[i].extInfoKey = CCOM.stubs.stbData.epg.eventExtData[i].extInfo[j].extInfoKey;										CCOM.stubs.stbData.epg.eventData[i].extInfoValue = CCOM.stubs.stbData.epg.eventExtData[i].extInfo[j].extInfoValue;										results.push(CCOM.stubs.stbData.epg.eventData[i]);									}								}							}							else							{								CCOM.stubs.stbData.epg.eventData[i].extInfoLanguage = CCOM.stubs.stbData.epg.eventExtData[i].extInfoLanguage;								CCOM.stubs.stbData.epg.eventData[i].extInfoKey = CCOM.stubs.stbData.epg.eventExtData[i].extInfo[j].extInfoKey;								CCOM.stubs.stbData.epg.eventData[i].extInfoValue = CCOM.stubs.stbData.epg.eventExtData[i].extInfo[j].extInfoValue;								results.push(CCOM.stubs.stbData.epg.eventData[i]);							}						}					}				}			}		}		if (results.length === 0)		{			this.logInfo("Did not catch it in CCOM.EPG.getEventsRSByExtInfo, RS.length==0.");			this.logInfo("criteria: " + criteria);			this.logInfo("fields: " + properties);		}		rs = new CCOM.ResultSet(results);		return rs;	};	this.getEventsRSByGenre = function(properties, genre, criteria, orderBy)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getEventsRSByTag = function(properties, tag, criteria, orderBy)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getExtInfoByEventId = function(eventId, language, maxCount)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getFavoriteLists = function()	{		var favList = [], i, fav_list_len = CCOM.stubs.stbData.epg.favoriteData.length, err = {			domain : "com.opentv.EPG",			name : "",			message : "no favorite list"		};		if (fav_list_len === 0)		{			return [];		}		for (i = 0; i < fav_list_len; i++)		{			favList[i] = CCOM.stubs.stbData.epg.favoriteData[i].listName;		}		return favList;	};	this.getGenresByEventId = function(eventId)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getGenresByServiceId = function(serviceId)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getServicesRSByGenre = function(properties, genreObj, criteria, orderBy) {        var results = [], i, j, rs, stmt, stmt1, queryResultSet, currentIndex,            regExp, serviceGenreArrLen, arrLen, matchArray,            epgStubData = CCOM.stubs.stbData.epg,            primaryServicePropPresent = false,		// [name, providerName, uriLogo]            genreArray = [],            serviceIdArray = [],            compareChannelKeyAsc = function (a, b) {                return a.channelKey - b.channelKey;            },            compareChannelKeyDsc = function (a, b) {                return b.channelKey - a.channelKey;            };        criteria = criteria || '';        genreObj.genre = genreObj.genre || '';        genreObj.contentNibbleLevel1 = genreObj.contentNibbleLevel1 || '';        genreObj.contentNibbleLevel2 = genreObj.contentNibbleLevel2 || '';        genreObj.languageCode = genreObj.languageCode || 'eng';        if (epgStubData.db) {        	 //for 5.1.5+            /*stmt = 'SELECT DISTINCT ' + properties + '' +        		' FROM Service, ServiceGenreDVB' +        		' ON Service.serviceId=ServiceGenreDVB.serviceId_Key AND Service.siNetworkType=ServiceGenreDVB.siNetworkType' +        		' LEFT JOIN ServiceText ON Service.serviceId=ServiceText.serviceId_Key AND' +        		' (ServiceText.textLanguageCode IS NULL OR (ServiceText.textLanguageCode=ServiceGenreDVB.textLanguageCode))' +        		' WHERE Service.siNetworkType=' + 256 + '';*/                        stmt = 'SELECT DISTINCT ' + properties +	    		' FROM Service, ServiceGenreDVB' +	    		' ON Service.serviceId = ServiceGenreDVB.serviceId_Key AND Service.siNetworkType = ServiceGenreDVB.siNetworkType' +	    		' WHERE Service.siNetworkType = ' + 256;                        if(genreObj.contentNibbleLevel1)            	stmt += ' AND ServiceGenreDVB.contentNibbleLevel1 = ' + genreObj.contentNibbleLevel1;                        if(genreObj.contentNibbleLevel2)            	stmt += ' AND ServiceGenreDVB.contentNibbleLevel2 = ' + genreObj.contentNibbleLevel2;                        if(genreObj.userByte)            	stmt += ' AND ServiceGenreDVB.userByte = ' + genreObj.userByte;                        if(genreObj.genre)            	stmt += ' AND ServiceGenreDVB.genre LIKE "' + genreObj.genre + '"';                        if(genreObj.languageCode)            	stmt += ' AND ServiceGenreDVB.languageCode = "' + genreObj.languageCode + '"';                        if(criteria)            	stmt += ' AND (' + criteria + ')';                        // for 5.1.5+//            stmt += ' GROUP BY Service.serviceId HAVING MAX( CASE WHEN languageCode IS @languageCodeP THEN 3 WHEN languageCode IS @languageCodeD THEN 2 ELSE 1 END)';            		    		if(orderBy)    			stmt += ' ORDER BY ' + orderBy;            stmt = epgStubData.db.prepare(stmt);            while (stmt.step()) {                queryResultSet = stmt.getAsObject();                results.push(queryResultSet);            }        } else {            serviceGenreArrLen = epgStubData.serviceGenre.length;            arrLen = epgStubData.genreLookup.length;            if (genreObj.genre) {                regExp = new RegExp(genreObj.genre, 'ig');                // filter genre                for (i = 0; i < arrLen ; ++i) {                    if (regExp.test(epgStubData.genreLookup[i].genre)) {                        genreArray.push({                            level1: epgStubData.genreLookup[i].level1,                            level2: epgStubData.genreLookup[i].level2                        });                    }                }            } else {                genreArray = epgStubData.genreLookup;            }            arrLen = genreArray.length;            if (arrLen) {		//when genres are available                matchArray = new RegExp(/^serviceId = '(\d+)'/).exec(criteria);                for (i = 0; i < arrLen; ++i) {                    for (j = 0; j < serviceGenreArrLen ; ++j) {                        if (genreArray[i].level1 === epgStubData.serviceGenre[j].level1 && genreArray[i].level2 === epgStubData.serviceGenre[j].level2) {                            if (criteria) {		// criteria of the serviceId filtered here                                if (matchArray && epgStubData.serviceGenre[j].serviceId_Key === matchArray[1]) {                                    serviceIdArray.push(epgStubData.serviceGenre[j].serviceId_Key);                                }                            } else {		// if no criteria                                serviceIdArray.push(epgStubData.serviceGenre[j].serviceId_Key);                            }                        }                    }                }                arrLen = epgStubData.serviceData.length;                for (i = 0; i < arrLen; ++i) {                    if (serviceIdArray.indexOf(epgStubData.serviceData[i].serviceId) !== -1) {                        results.push(epgStubData.serviceData[i]);                    }                }            }            if (results.length) {                if (orderBy === "channelKey asc") {                    results.sort(compareChannelKeyAsc);                } else if (orderBy === "channelKey dsc") {                    results.sort(compareChannelKeyDsc);                }            }        }        if (results.length === 0) {            this.logInfo("[CCOM.EPG.getServicesRSByGenre]Did not match to any service of genre");            this.logInfo("criteria: " + criteria);            this.logInfo("fields: " + properties);        }        rs = new CCOM.ResultSet(results);        return rs;    };	this.getServicesRSByTag = function(properties, tag, criteria, order)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getServicesRSByComponent = function(properties, component, criteria, orderBy)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getEventsRSByComponent = function(properties, component, criteria, orderBy)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getComponentsByServiceId = function(serviceId, language)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getComponentsByEventId = function(eventId, language)	{		this.logWarning("This API has not been implemented yet!");		return {			error : {				domain : "com.opentv.EPG",				name : "Unimplemented",				message : ""			}		};	};	this.getServicesRSByFavoriteList = function(properties, listName)	{		var i, fav_list_len = CCOM.stubs.stbData.epg.favoriteData.length, err = {			domain : "com.opentv.EPG",			name : "TBD",			message : "can not find favorite service list!"		}, results = [], rs, services_index, fav_services_index;		for (i = 0; i < fav_list_len; i++)		{			if (String(CCOM.stubs.stbData.epg.favoriteData[i].listName) === String(listName))			{				if (CCOM.stubs.stbData.epg.favoriteData[i].serviceIds.length <= 0)				{					//return result is empty					break;				}				for (services_index = 0; services_index < CCOM.stubs.stbData.epg.serviceData.length; services_index++)				{					for (fav_services_index = 0; fav_services_index < CCOM.stubs.stbData.epg.favoriteData[i].serviceIds.length; fav_services_index++)					{						if (String(CCOM.stubs.stbData.epg.serviceData[services_index].serviceId) === String(CCOM.stubs.stbData.epg.favoriteData[i].serviceIds[fav_services_index]))						{							results.push(CCOM.stubs.stbData.epg.serviceData[services_index]);						}					}				}				break;			}		}		if (results.length === 0)		{			this.logInfo("[CCOM.EPG.getServicesRSByFavoriteList] no matching result");		}		rs = new CCOM.ResultSet(results);		return rs;	};	this.removeFavoriteList = function(listName)	{		var i, _handle = CCOM.stubs.getHandle(), fav_list_len = CCOM.stubs.stbData.epg.favoriteData.length;		for (i = 0; i < fav_list_len; i++)		{			if (String(CCOM.stubs.stbData.epg.favoriteData[i].listName) === String(listName))			{				CCOM.stubs.stbData.epg.favoriteData.splice(i, 1);				break;			}		}		if (i < fav_list_len)		{			CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_FAVORITE_LIST_OK, {				handle : _handle			});			return _handle;		}		else		{			CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_FAVORITE_LIST_FAILED, {				handle : _handle,				error : {					domain : "com.opentv.EPG",					name : "TBD",					message : "The listName favlist can't be removed!"				}			});			return _handle;		}	};	this.setFavoriteList = function(newListName, newServiceIds)	{		var i, newFav, _handle = CCOM.stubs.getHandle(), fav_list_len = CCOM.stubs.stbData.epg.favoriteData.length;		for (i = 0; i < fav_list_len; i++)		{			if (String(CCOM.stubs.stbData.epg.favoriteData[i].listName) === String(newListName))			{				//fav list has been existed				CCOM.stubs.stbData.epg.favoriteData[i].serviceIds = newServiceIds;				break;			}		}		if (i === fav_list_len)		{			newFav = {				listName : newListName,				serviceIds : newServiceIds			};			CCOM.stubs.stbData.epg.favoriteData.push(newFav);		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_SET_FAVORITE_LIST_OK, {			handle : _handle		});		return _handle;	};	// 5.0 doc do not include this function, but if it is not defined, gravity can not be run.	this.getTagsByServiceId = function(serviceId)	{		var i, _handle = CCOM.stubs.getHandle();		if (CCOM.stubs.stbData.epg.db)		{			this.logWarning("This API has not been implemented yet!");			return {				error : {					domain : "com.opentv.CCOM",					name : "Failed",					message : "Not implemented yet"				}			};		}		else		{			for (i = 0; i < CCOM.stubs.stbData.epg.serviceData.length; i++)			{				if (CCOM.stubs.stbData.epg.serviceData[i].serviceId === serviceId)				{					if (!CCOM.stubs.stbData.epg.serviceData[i].tags)					{						return [];					}					else					{						return CCOM.stubs.stbData.epg.serviceData[i].tags;					}				}			}		}		return [];	};	this.addEventListener = function(event, callback)	{		if (-1 === this._supportedEvents.indexOf(event))		{			return CCOM.stubs.ERROR_INVALID_EVENT;		}		return CCOM.stubs.addEventListener(this._id, this._MY_NAME_SPACE, event, callback);	};	this.removeEventListener = function(event, callback)	{		if (-1 === this._supportedEvents.indexOf(event))		{			return CCOM.stubs.ERROR_INVALID_EVENT;		}		return CCOM.stubs.removeEventListener(this._id, this._MY_NAME_SPACE, event, callback);	};	this.getTagsByEventId = function(eventId)	{		var i, _handle = CCOM.stubs.getHandle();		if (CCOM.stubs.stbData.epg.db)		{			this.logWarning("This API has not been implemented yet!");			return {				error : {					domain : "com.opentv.CCOM",					name : "Failed",					message : "Not implemented yet"				}			};		}		else		{			for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)			{				if (CCOM.stubs.stbData.epg.eventData[i].eventId === eventId)				{					if (!CCOM.stubs.stbData.epg.eventData[i].tags)					{						return [];					}					else					{						return CCOM.stubs.stbData.epg.eventData[i].tags;					}				}			}		}		return [];	};	this.addService = function(service, update)	{		if (CCOM.stubs.stbData.epg.db)		{                                //@hdk added, but disabled				var sql = "INSERT INTO Service (source,id,logicalChannelNum,deliveryMethod,serviceName,"+																				"parentalRating,locale,startOverSupport,catchUpSupport,"+																				"mainChannelId,NetworkLocation,logo,genres,serviceId,"+																				"uri,type,name,channelKey) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?');";				//console.log(sql);				if (false) {					var stmt = CCOM.stubs.stbData.epg.db.run(sql, [									 service.source, service.id, service.logicalChannelNum, service.deliveryMethod, service.serviceName, 									 service.parentalRating, service.locale, service.startOverSupport, service.catchUpSupport, 									 service.mainChannelId, service.NetworkLocation, service.logo,(service.genres?service.genres[0]:''), service.serviceId, 									 service.uri, service.type, service.name, service.channelKey								 ]);				}								 				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_SERVICE_OK, {					handle : _handle				});				return _handle;		}		else		{			var i, _handle = CCOM.stubs.getHandle(), ori_services_data_len = CCOM.stubs.stbData.epg.serviceData.length, property;			for (i = 0; i < ori_services_data_len; i++)			{				if (String(CCOM.stubs.stbData.epg.serviceData[i].serviceId) === String(service.serviceId))				{					if (update === 0)					{						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_SERVICE_FAILED, {							handle : _handle,							error : {								domin : "com.opentv.EPG",								name : "Duplicate",								message : "The service entry already exists and update=0!"							}						});						return _handle;					}					else					{						//update the exist event entry						for (property in CCOM.stubs.stbData.epg.serviceData[i])						{							if (CCOM.stubs.stbData.epg.serviceData[i].hasOwnProperty(property) && service.hasOwnProperty(property))							{								CCOM.stubs.stbData.epg.serviceData[i][property] = service[property];							}							//else the property of service data will not be changed						}						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_SERVICE_OK, {							handle : _handle						});						return _handle;					}				}			}			// add a new event entry			if (String(service.uri) && String(service.serviceId))			{				CCOM.stubs.stbData.epg.serviceData.push(service);				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_SERVICE_OK, {					handle : _handle				});				return _handle;			}			else			{				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_SERVICE_FAILED, {					handle : _handle,					error : {						domin : "com.opentv.EPG",						name : "Database",						message : "The required service content (uri or serviceID) doesn't exist when attempting to add a new event entry!"					}				});				return _handle;			}		}	};	this.removeExpiredEvents = function(retentionTime)	{		var _handle = CCOM.stubs.getHandle(), ori_event_data_len = CCOM.stubs.stbData.epg.eventData.length, i;		for (i = ori_event_data_len - 1; i >= 0; i--)		{			if (CCOM.stubs.stbData.epg.eventData[i].endTime < retentionTime)			{				CCOM.stubs.stbData.epg.eventData.splice(i, 1);			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_EXPIRED_EVENTS_OK, {			handle : _handle		});		return _handle;	};	this.tagEvent = function(eventId, tagId, tagValue)	{		var i, j, _handle = CCOM.stubs.getHandle();		if (CCOM.stubs.stbData.epg.db)		{			this.logWarning("This API has not been implemented yet!");			return {				error : {					domain : "com.opentv.CCOM",					name : "Failed",					message : "Not implemented yet"				}			};		}		else		{			for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)			{				if (CCOM.stubs.stbData.epg.eventData[i].eventId === eventId)				{					if (!CCOM.stubs.stbData.epg.eventData[i].tags)					{						CCOM.stubs.stbData.epg.eventData[i].tags = [];					}					/* Check if the tag already exists */					for (j = 0; j < CCOM.stubs.stbData.epg.eventData[i].tags.length; j++)					{						if (CCOM.stubs.stbData.epg.eventData[i].tags[j].tagId === tagId)						{							CCOM.stubs.stbData.epg.eventData[i].tags[j].tagValue = tagValue;							CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_TAG_EVENT_OK, {								handle : _handle							});							return _handle;						}					}					CCOM.stubs.stbData.epg.eventData[i].tags.push({						tagId : tagId,						tagValue : tagValue					});					CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_TAG_EVENT_OK, {						handle : _handle					});					return _handle;				}			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_TAG_EVENT_FAILED, {			handle : _handle,			error : {				domin : "com.opentv.EPG",				name : "NotFound",				message : ""			}		});		return _handle;	};	this.tagService = function(serviceId, tagId, tagValue)	{		var i, j, _handle = CCOM.stubs.getHandle();		if (CCOM.stubs.stbData.epg.db)		{			this.logWarning("This API has not been implemented yet!");			return {				error : {					domain : "com.opentv.CCOM",					name : "Failed",					message : "Not implemented yet"				}			};		}		else		{			for (i = 0; i < CCOM.stubs.stbData.epg.serviceData.length; i++)			{				if (CCOM.stubs.stbData.epg.serviceData[i].serviceId === serviceId)				{					if (!CCOM.stubs.stbData.epg.serviceData[i].tags)					{						CCOM.stubs.stbData.epg.serviceData[i].tags = [];					}					/* Check if the tag already exists */					for (j = 0; j < CCOM.stubs.stbData.epg.serviceData[i].tags.length; j++)					{						if (CCOM.stubs.stbData.epg.serviceData[i].tags[j].tagId === tagId)						{							CCOM.stubs.stbData.epg.serviceData[i].tags[j].tagValue = tagValue;							CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_TAG_SERVICE_OK, {								handle : _handle							});							return _handle;						}					}					CCOM.stubs.stbData.epg.serviceData[i].tags.push({						tagId : tagId,						tagValue : tagValue					});					CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_TAG_SERVICE_OK, {						handle : _handle					});					return _handle;				}			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_TAG_SERVICE_FAILED, {			handle : _handle,			error : {				domin : "com.opentv.EPG",				name : "NotFound",				message : ""			}		});		return _handle;	};	this.untagEvent = function(eventId, tagId)	{		var i, j, _handle = CCOM.stubs.getHandle();		for (i = 0; i < CCOM.stubs.stbData.epg.eventData.length; i++)		{			if (CCOM.stubs.stbData.epg.eventData[i].eventId === eventId)			{				if (!CCOM.stubs.stbData.epg.eventData[i].tags)				{					break;				}				for (j = 0; j < CCOM.stubs.stbData.epg.eventData[i].tags.length; j++)				{					if (CCOM.stubs.stbData.epg.eventData[i].tags[j].tagId === tagId)					{						CCOM.stubs.stbData.epg.eventData[i].tags.splice(j, 1);						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_UNTAG_EVENT_OK, {							handle : _handle						});						return _handle;					}				}				break;			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_UNTAG_EVENT_FAILED, {			handle : _handle,			error : {				domin : "com.opentv.EPG",				name : "NotFound",				message : ""			}		});		return _handle;	};	this.untagService = function(serviceId, tagId)	{		var i, j, _handle = CCOM.stubs.getHandle();		for (i = 0; i < CCOM.stubs.stbData.epg.serviceData.length; i++)		{			if (CCOM.stubs.stbData.epg.serviceData[i].serviceId === serviceId)			{				if (!CCOM.stubs.stbData.epg.serviceData[i].tags)				{					break;				}				for (j = 0; j < CCOM.stubs.stbData.epg.serviceData[i].tags.length; j++)				{					if (CCOM.stubs.stbData.epg.serviceData[i].tags[j].tagId === tagId)					{						CCOM.stubs.stbData.epg.serviceData[i].tags.splice(j, 1);						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_UNTAG_SERVICE_OK, {							handle : _handle						});						return _handle;					}				}				break;			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_UNTAG_SERVICE_FAILED, {			handle : _handle,			error : {				domin : "com.opentv.EPG",				name : "NotFound",				message : ""			}		});		return _handle;	};        //@hdk added for extra info	this.dumpEvents = function(sql)	{		if (CCOM.stubs.stbData.epg.db)		{			console.log(sql);			var stmt = CCOM.stubs.stbData.epg.db.prepare(sql);			while (stmt.step()) {				var result = stmt.getAsObject();				console.log(JSON.stringify(result));			}		}	}			this.addEvent = function(event, update)	{		if (CCOM.stubs.stbData.epg.db)		{                                //@hdk added to be able to inject events in the db				var _handle = CCOM.stubs.getHandle(),					keys = Object.keys(event),					values = Object.values(event),					sql = (update?"REPLACE":"INSERT")+" INTO Event ("+keys.join(", ")+") VALUES ("+(Array(keys.length).join("?,"))+"?);";				if (this._sqlBatch === undefined) { // no batch ongoing					var stmt = CCOM.stubs.stbData.epg.db.run(sql, values);				}				values.forEach(function(value, n) {						if (typeof value === 'string') {							values[n] = value.replace(/"/g, "'");						}					});				//console.log((update?'REPLACE':'INSERT')+' INTO Event ('+keys.join(', ')+') VALUES ("'+values.join('", "')+'");');				if (this._sqlBatch !== undefined) { // no batch ongoing					this._sqlBatch.push((update?'REPLACE':'INSERT')+' INTO Event ('+keys.join(', ')+') VALUES ("'+values.join('", "')+'");');					//console.log(this._sqlBatch.length);				}				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_EVENT_OK, {					handle : _handle				});				return _handle;		}		else		{			var i, property, _handle = CCOM.stubs.getHandle(), ori_event_data_len = CCOM.stubs.stbData.epg.eventData.length;			for (i = 0; i < ori_event_data_len; i++)			{                                //@hdk added check for serviceId, for Foxtel eventIds are only unique per service				if (String(CCOM.stubs.stbData.epg.eventData[i].eventId) === String(event.eventId) && 						String(CCOM.stubs.stbData.epg.eventData[i].serviceId) === String(event.serviceId))				{					if (update === 0)					{						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_EVENT_FAILED, {							handle : _handle,							error : {								domin : "com.opentv.EPG",								name : "Duplicate",								message : "The event entry already exists and update=0!"							}						});						return _handle;					}					else					{						//update the exist event entry						for (property in CCOM.stubs.stbData.epg.eventData[i])						{							if (CCOM.stubs.stbData.epg.eventData[i].hasOwnProperty(property) && event.hasOwnProperty(property))							{								CCOM.stubs.stbData.epg.eventData[i][property] = event[property];							}							//else the property of event data will not be changed						}						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_EVENT_OK, {							handle : _handle						});						return _handle;					}				}			}			// add a new event entry			if (String(event.eventId) && String(event.serviceId) && String(event.startTime) && String(event.endTime))			{				//if seviceid is not identified by sevice database, the event will not be filled				for (i = 0x0; i < CCOM.stubs.stbData.epg.serviceData.length; i++)				{					if (String(CCOM.stubs.stbData.epg.serviceData[i].serviceId) === String(event.serviceId))					{						CCOM.stubs.stbData.epg.eventData.push(event);						CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_EVENT_OK, {							handle : _handle						});						return _handle;					}				}				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_EVENT_FAILED, {					handle : _handle,					error : {						domin : "com.opentv.EPG",						name : "Database",						message : "The service ID does not exist!"					}				});				return _handle;			}			else			{				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_ADD_EVENT_FAILED, {					handle : _handle,					error : {						domin : "com.opentv.EPG",						name : "Database",						message : "The required event content doesn't exist when attempting to add a new event entry!"					}				});				return _handle;			}		}	};	this.removeEvent = function(eventId)	{		var i, _handle = CCOM.stubs.getHandle(), ori_event_data_len = CCOM.stubs.stbData.epg.eventData.length;		for (i = 0; i < ori_event_data_len; i++)		{			if (String(CCOM.stubs.stbData.epg.eventData[i].eventId) === String(eventId))			{				CCOM.stubs.stbData.epg.eventData.splice(i, 1);				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_EVENT_OK, {					handle : _handle				});				return _handle;			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_EVENT_FAILED, {			handle : _handle,			error : {				domin : "com.opentv.EPG",				name : "NotFound",				message : "The event doesn't exist!"			}		});		return _handle;	};	this.removeService = function(serviceId)	{		var i, _handle = CCOM.stubs.getHandle(), ori_service_data_len = CCOM.stubs.stbData.epg.serviceData.length;		for (i = 0; i < ori_service_data_len; i++)		{			if (String(CCOM.stubs.stbData.epg.serviceData[i].serviceId) === String(serviceId))			{				CCOM.stubs.stbData.epg.serviceData.splice(i, 1);				CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_SERVICE_OK, {					handle : _handle				});				return _handle;			}		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_REMOVE_SERVICE_FAILED, {			handle : _handle,			error : {				domin : "com.opentv.EPG",				name : "NotFound",				message : "The service doesn't exist!"			}		});		return _handle;	};	this.beginBatch = function()	{		this.logWarning("This API has not been implemented yet!");		var _handle = CCOM.stubs.getHandle();                //@hdk added but disabled, code not completed		if (false && CCOM.stubs.stbData.epg.db) {			if (this._sqlBatch === undefined || this._sqlBatch.length == 0) {				this._sqlBatch = [];			} else {				CCOM.stubs.log("[CCOM.EPG.beginBatch] batch ongoing!");			}		} else {			CCOM.stubs.log("[CCOM.EPG.beginBatch] Unimplemented!");		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_BEGIN_BATCH_OK, {			handle : _handle		});		return _handle;	};	this.cancelBatch = function()	{		this.logWarning("This API has not been implemented yet!");		var _handle = CCOM.stubs.getHandle();                //@hdk added but disabled, code not completed		if (false && CCOM.stubs.stbData.epg.db) {			this._sqlBatch = undefined;		} else {			CCOM.stubs.log("[CCOM.EPG.cancelBatch] Unimplemented!");		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_CANCEL_BATCH_OK, {			handle : _handle		});		return _handle;	};	this.commitBatch = function()	{		this.logWarning("This API has not been implemented yet!");		var _handle = CCOM.stubs.getHandle();                //@hdk added but disabled, code not completed		if (false && CCOM.stubs.stbData.epg.db) {			if (this._sqlBatch !== undefined) {				CCOM.stubs.log("[CCOM.EPG.commitBatch] "+this._sqlBatch.length);				var stmt = CCOM.stubs.stbData.epg.db.run(this._sqlBatch.join(" "));				this._sqlBatch = undefined;			}		} else {			CCOM.stubs.log("[CCOM.EPG.commitBatch] Unimplemented!");		}		CCOM.stubs.raiseEvent(this._id, this._MY_NAME_SPACE, this._EVENT_COMMIT_BATCH_OK, {			handle : _handle		});		return _handle;	};})();